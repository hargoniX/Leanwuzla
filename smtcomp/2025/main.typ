#import "@preview/charged-ieee:0.1.3": ieee

#show: ieee.with(
  title: [`bv_decide` at the SMT-COMP 2025],
  abstract: [
    This paper presents our SMT solver `bv_decide` as submitted to SMT-COMP 2025.
    `bv_decide` is a solver for the quantifier-free theory of bit-vectors.
  ],
  authors: (
    (
      name: "Henrik Böving",
      organization: [Lean FRO],
    ),
    (
      name: "Siddharth Bhat",
      organization: [University of Cambridge],
    ),
    (
      name: "Alex Keizer",
      organization: [University of Cambridge],
    ),
    (
      name: "Luisa Cicolini",
      organization: [University of Cambridge],
    ),
    (
      name: "Leon Frenot",
      organization: [ENS Lyon],
    ),
    (
      name: "Abdalrhman Mohamed",
      organization: [Stanford University],
    ),
    (
      name: "Léo Stefanesco",
      organization: [University of Cambridge],
    ),
    (
      name: "Harun Khan",
      organization: [Stanford University],
    ),
    (
      name: "Josh Clune",
      organization: [Carnegie Mellon University],
    ),
    (
      name: "Clark Barrett",
      organization: [Stanford University],
    ),
    (
      name: "Tobias Grosser",
      organization: [University of Cambridge],
    ),
  ),
  bibliography: bibliography("refs.bib"),
)

= Introduction

`bv_decide` is a Lean 4 @lean4 tactic for deciding quantifier-free bit-vector `QF_BV` formulas.
It eagerly determines satisfiability by rewriting and simplifying bit-vector formulas,
bit-blasting them into propositional logic, and invoking a SAT solver with certificate checking.

Algorithmically, `bv_decide` follows the approach of the Bitwuzla SMT solver @bitwuzla, with the
crucial twist that the solver is implemented and verified as part of the Lean 4 theorem prover
and programming language. Furthermore, to ensure the end-to-end correctness of results,
`bv_decide` also checks the LRAT @lrat certificate produced by the SAT backend.

= Core (Verified) Components

1. *Bitvector Rewrites:* Inspired by Bitwuzla's equational rewrite rules to simplify `QF_BV` formulas.
  All rewrite rules are formally verified in Lean for arbitrary bit-widths, ensuring semantic equivalence.

2. *Bit-Blasting Engine:* Transforms simplified bit-vector expressions into an And-Inverter Graph (AIG)
  and then into CNF. Built atop a verified AIG framework that uses Lean's imperative arrays and
  hash maps for efficient in-place operations.

3. *LRAT Checker:* After encoding the AIG to CNF, `bv_decide` invokes the SAT backend on the CNF problem,
  which emits an LRAT certificate if the problem is UNSAT. The verified LRAT checker then validates
  the UNSAT proof and trims unused proof steps, following the `lrat-trim` strategy @lrat-trim.

= Certifying Components

The following components are not verified but output certificates that are checked by other
components of `bv_decide`:

1. *SAT Backend:* The SAT backend does not need to be verified and is treated as a black box. However,
  we require it to produce a valid LRAT certificate, which is then checked by the verified LRAT checker.

2. *Rewrite Engine:* The proof generated by this engine during the transformation of the original
  bit-vector formula is checked by the Lean kernel.

= Sources of Error

Despite end-to-end verification, three low-probability sources of error remain:

1. *Parsing Errors*, which may cause `bv_decide` to misinterpret SMT-LIB input. `bv_decide` is
  developed as an integrated tactic for Lean and thus does not natively support the SMT-LIB format.
  To use it in SMT-COMP, we developed a wrapper called `leanwuzla` @leanwuzla that translates
  SMT-LIB queries into Lean propositions for `bv_decide` to decide. This wrapper is not formally verified.
  However, extensive testing on SMT-LIB 2024 provides high confidence in its correctness.

2. *Compiler Bugs* in Lean 4, which might produce a binary misaligned with source semantics.
  Again, successful runs on SMT-LIB 2024 benchmarks offer indirect validation.

3. *Kernel Unsoundness*, which could undermine proof checking. The Lean kernel follows the De Bruijn criterion
  @barendregt2005challenge and has a small, audited codebase, making serious soundness failures extremely unlikely.
  Most soundness issues in the past have been due to proofs specifically crafted to exploit particular
  implementation vulnerabilities. Since we perform fairly standard reasoning, we do not believe this
  to be a serious concern.

= Competition Entry

`bv_decide` competes in the single-query track of the `QF_BV` logic at SMT-COMP 2025,
using CaDiCaL 2.1.2 @cadical as its SAT solver.

= License

Both `bv_decide` and its SMT-LIB wrapper `leanwuzla` are released under the Apache 2.0 license.
